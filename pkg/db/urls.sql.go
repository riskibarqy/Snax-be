// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: urls.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addURLTag = `-- name: AddURLTag :exec
INSERT INTO url_tags (url_id, tag_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddURLTagParams struct {
	UrlID int32 `json:"url_id"`
	TagID int32 `json:"tag_id"`
}

func (q *Queries) AddURLTag(ctx context.Context, arg AddURLTagParams) error {
	_, err := q.db.Exec(ctx, addURLTag, arg.UrlID, arg.TagID)
	return err
}

const createAnalytics = `-- name: CreateAnalytics :one
INSERT INTO analytics (
    url_id,
    visitor_ip,
    user_agent,
    referer,
    country_code,
    device_type
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, url_id, visitor_ip, user_agent, referer, timestamp, country_code, device_type
`

type CreateAnalyticsParams struct {
	UrlID       pgtype.Int4 `json:"url_id"`
	VisitorIp   pgtype.Text `json:"visitor_ip"`
	UserAgent   pgtype.Text `json:"user_agent"`
	Referer     pgtype.Text `json:"referer"`
	CountryCode pgtype.Text `json:"country_code"`
	DeviceType  pgtype.Text `json:"device_type"`
}

func (q *Queries) CreateAnalytics(ctx context.Context, arg CreateAnalyticsParams) (Analytic, error) {
	row := q.db.QueryRow(ctx, createAnalytics,
		arg.UrlID,
		arg.VisitorIp,
		arg.UserAgent,
		arg.Referer,
		arg.CountryCode,
		arg.DeviceType,
	)
	var i Analytic
	err := row.Scan(
		&i.ID,
		&i.UrlID,
		&i.VisitorIp,
		&i.UserAgent,
		&i.Referer,
		&i.Timestamp,
		&i.CountryCode,
		&i.DeviceType,
	)
	return i, err
}

const createURL = `-- name: CreateURL :one
INSERT INTO urls (
    short_code,
    original_url,
    user_id,
    expires_at
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, original_url, short_code, user_id, created_at, expires_at, click_count, is_active
`

type CreateURLParams struct {
	ShortCode   string             `json:"short_code"`
	OriginalUrl string             `json:"original_url"`
	UserID      pgtype.Text        `json:"user_id"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateURL(ctx context.Context, arg CreateURLParams) (Url, error) {
	row := q.db.QueryRow(ctx, createURL,
		arg.ShortCode,
		arg.OriginalUrl,
		arg.UserID,
		arg.ExpiresAt,
	)
	var i Url
	err := row.Scan(
		&i.ID,
		&i.OriginalUrl,
		&i.ShortCode,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.ClickCount,
		&i.IsActive,
	)
	return i, err
}

const deactivateURL = `-- name: DeactivateURL :exec
UPDATE urls
SET is_active = false
WHERE id = $1 AND user_id = $2
`

type DeactivateURLParams struct {
	ID     int32       `json:"id"`
	UserID pgtype.Text `json:"user_id"`
}

func (q *Queries) DeactivateURL(ctx context.Context, arg DeactivateURLParams) error {
	_, err := q.db.Exec(ctx, deactivateURL, arg.ID, arg.UserID)
	return err
}

const getAnalyticsByURLID = `-- name: GetAnalyticsByURLID :many
SELECT id, url_id, visitor_ip, user_agent, referer, timestamp, country_code, device_type FROM analytics
WHERE url_id = $1
ORDER BY timestamp DESC
`

func (q *Queries) GetAnalyticsByURLID(ctx context.Context, urlID pgtype.Int4) ([]Analytic, error) {
	rows, err := q.db.Query(ctx, getAnalyticsByURLID, urlID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Analytic{}
	for rows.Next() {
		var i Analytic
		if err := rows.Scan(
			&i.ID,
			&i.UrlID,
			&i.VisitorIp,
			&i.UserAgent,
			&i.Referer,
			&i.Timestamp,
			&i.CountryCode,
			&i.DeviceType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getURLByShortCode = `-- name: GetURLByShortCode :one
SELECT id, original_url, short_code, user_id, created_at, expires_at, click_count, is_active FROM urls
WHERE short_code = $1 AND is_active = true
`

func (q *Queries) GetURLByShortCode(ctx context.Context, shortCode string) (Url, error) {
	row := q.db.QueryRow(ctx, getURLByShortCode, shortCode)
	var i Url
	err := row.Scan(
		&i.ID,
		&i.OriginalUrl,
		&i.ShortCode,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.ClickCount,
		&i.IsActive,
	)
	return i, err
}

const getURLTags = `-- name: GetURLTags :many
SELECT t.id, t.name FROM tags t
JOIN url_tags ut ON ut.tag_id = t.id
WHERE ut.url_id = $1
`

func (q *Queries) GetURLTags(ctx context.Context, urlID int32) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getURLTags, urlID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getURLsByUserID = `-- name: GetURLsByUserID :many
SELECT id, original_url, short_code, user_id, created_at, expires_at, click_count, is_active FROM urls
WHERE user_id = $1 AND is_active = true
ORDER BY created_at DESC
`

func (q *Queries) GetURLsByUserID(ctx context.Context, userID pgtype.Text) ([]Url, error) {
	rows, err := q.db.Query(ctx, getURLsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Url{}
	for rows.Next() {
		var i Url
		if err := rows.Scan(
			&i.ID,
			&i.OriginalUrl,
			&i.ShortCode,
			&i.UserID,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.ClickCount,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementClickCount = `-- name: IncrementClickCount :one
UPDATE urls
SET click_count = click_count + 1
WHERE id = $1
RETURNING click_count
`

func (q *Queries) IncrementClickCount(ctx context.Context, id int32) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, incrementClickCount, id)
	var click_count pgtype.Int4
	err := row.Scan(&click_count)
	return click_count, err
}
